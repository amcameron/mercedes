var ops;

module.exports = function (_ops) {
	ops = _ops;
	var api = {
		preprocess: function (root, fileStats) {
			return preprocessFile(root, fileStats);
		},
		merge: function (root, fileStats) {
			var cmdline = preprocessFile(root, fileStats);
			if (cmdline && cmdline.length > 0)
				spawnProcess('mkvmerge', cmdline);
		},
		__testonly__: {}
	};

		/* test-code */
		api.__testonly__.parseSrt = parseSrt
		api.__testonly__.getCmdLine = getCmdLine
		/* end-test-code */


	return api;
}

var fs = require('fs');
var path = require('path');
var glob = require("glob")

function preprocessFile(root, fileStats) {
	var cmdline = [];

	if (fileStats.isFile()) {
		if (fileStats.name.lastIndexOf(".mkv") != -1
			|| fileStats.name.lastIndexOf(".avi") != -1
			|| fileStats.name.lastIndexOf(".mp4") != -1
			|| fileStats.name.lastIndexOf(".divx") != -1) {
			cmdline = getCmdLine(root, fileStats.name);
			}
		}


	return cmdline;
}

function spawnProcess(procName, cmdline) {

	var spawn = require('child_process').spawn,
		ls = spawn(procName, cmdline);

	ls.stdout.on('data', function (data) {
		console.log('stdout: ' + path.basename(cmdline[2]) + ' --- ' + data);
	});

	ls.stderr.on('data', function (data) {
		console.log('stderr: ' + data);
	});

	ls.on('close', function (code) {
		console.log('child process exited with code ' + code);
	});


}

function syncProcess(procName, cmdline) {
	var sh = require('execSync');

	cmdline.unshift(procName);
	var result = sh.exec(cmdline.join(' '));
}


function parseSrt(filepath, size) {
	var result = {};
	var tokens = filepath.split('.');
	if(tokens.length > 2  && tokens[tokens.length - 2].length == size) {
		result.lang = tokens[tokens.length - 2];
	}	

	if(size == 2) {
		if(result.lang === "sp" || result.lang === "es")
			result.lang = "spa";
		else if(result.lang === "en")
			result.lang = "eng";
		else
			result = {};
	}

	if(size == -1) {
		result.lang = ops.default_lang;
	}
	
	return result;
}

function logArray(array) {
	array.forEach(function (entry) {
		console.log(entry);
	});
}

function getCmdLine(root, videoFileName) {

	if (ops.verbose) {
		console.log(ops);
		console.log("---------- " + root + "----" + videoFileName + " -------");
	}

	var cmdline =[];

	var fullPath = [root, '/', videoFileName].join('');
	var basename = path.basename(fullPath, path.extname(videoFileName));
	var options = {cwd: root};

	var mask = [basename, '.', '[a-z][a-z][a-z]', '.srt'].join('');
	var srtFiles = glob.sync(mask, options);
	cmdline = getSubtitleCmdLine(root, srtFiles, 3);

	mask = [basename, '.', '[a-z][a-z]', '.srt'].join('');
	srtFiles = glob.sync(mask, options);
	var subsCmdLine = getSubtitleCmdLine(root, srtFiles, 2);
	if(subsCmdLine.length > 0)
		cmdline = cmdline.concat(subsCmdLine);

	mask = [basename, '.srt'].join('');
	srtFiles = glob.sync(mask, options);
	subsCmdLine = getSubtitleCmdLine(root, srtFiles, -1);
	if(subsCmdLine.length > 0)
		cmdline = cmdline.concat(subsCmdLine);

	if (ops.verbose && cmdline.length == 0) {
		console.log("no subtitles found for: " + videoFileName);
	}
			
	if(cmdline.length > 0) {
		var date_str = new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '')
		var newFile = [root, '/', basename, ' --- GENERATED ', date_str, '.mkv'].join('');
		if (ops.verbose)
			console.log("ABOUT TO GENERATE: " + newFile);

		cmdline.unshift(fullPath);
		cmdline.unshift(newFile);
		cmdline.unshift('-o');
		
		if (ops.verbose) {
			console.log("WITH cmdline: ");
			logArray(cmdline);
		}
	}

	return cmdline;

}

function getSubtitleCmdLine(root, srtFiles, size)
{
		var cmdline = [];

		if(srtFiles.length > 0) {
			srtFiles.forEach(function(file) {
				var parseRes = parseSrt(file, size);
				if(parseRes.lang) {
					if(parseRes.lang !== "eng") {
						cmdline.push("--language");
						cmdline.push("0:" + parseRes.lang);
					}
					if(parseRes.lang === "spa") {
						cmdline.push("--sub-charset");
						cmdline.push("0:" + ops.spa_enc);
						cmdline.push("--default-track");
						cmdline.push("0:yes");
					}
					cmdline.push(root + "/" + file);
					
				}
			});
		}
		

		return cmdline;
}